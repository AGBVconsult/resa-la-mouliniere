import fs from "node:fs";
import path from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";

export type ExtractResult = {
  reservationStatuses: string[];
  errorCodes: string[];
  services: string[];
  languages: string[];
  slotTakenReasons: string[];
  expectedQueries: string[];
  expectedMutations: string[];
  expectedActions: string[];
};

export function normalizeEol(input: string): string {
  return input.replace(/\r\n/g, "\n");
}

function uniq<T>(arr: T[]): T[] {
  return [...new Set(arr)];
}

function extractBetween(md: string, startRegex: RegExp, endRegex: RegExp): string {
  const startMatch = md.match(startRegex);
  if (!startMatch || startMatch.index === undefined) return "";
  const startIndex = startMatch.index + startMatch[0].length;
  const rest = md.slice(startIndex);
  const endMatch = rest.match(endRegex);
  const endIndex = endMatch?.index ?? rest.length;
  return rest.slice(0, endIndex);
}

function extractBacktickedList(block: string): string[] {
  const out: string[] = [];
  const re = /^-\s+`([^`]+)`/gm;
  for (const m of block.matchAll(re)) out.push(m[1]);
  return out;
}

function extractErrorCodes(md: string): string[] {
  const block = extractBetween(md, /^\s*###\s*4\.2\s*Codes\s*\(liste complète\)\s*\n/m, /^\s*Meta standardisée/m);
  const out: string[] = [];
  const re = /^-\s+`([A-Z0-9_]+)`\s*\(/gm;
  for (const m of block.matchAll(re)) out.push(m[1]);
  return out;
}

function extractReservationStatuses(md: string): string[] {
  const block = extractBetween(md, /^\s*###\s*3\.1\s*Reservation\.status\s*\(exhaustif\)\s*\n/m, /^\s*###\s*3\.2\s*/m);
  return extractBacktickedList(block).map((s) => s.replace(/^"|"$/g, ""));
}

function extractServices(md: string): string[] {
  const m = md.match(/^\s*-\s+`service`\s*:\s*union string\s*`([^`]+)`\s*\./m);
  if (!m) return ["lunch", "dinner"]; // fallback strict contract
  return m[1]
    .split("|")
    .map((s) => s.trim().replace(/^"|"$/g, ""))
    .filter(Boolean);
}

function extractLanguages(md: string): string[] {
  const m = md.match(/^\s*-\s+`language`\s*:\s*"([^"]+)"\s*\|\s*"([^"]+)"\s*\|\s*"([^"]+)"\s*\|\s*"([^"]+)"\s*\|\s*"([^"]+)"\s*$/m);
  if (!m) return ["fr", "nl", "en", "de", "it"];
  return [m[1], m[2], m[3], m[4], m[5]];
}

function extractSlotTakenReasons(md: string): string[] {
  const line = md.match(/SLOT_TAKEN\.meta:\s*`\{[^`]*reason\?:\s*"([^"]+)"\s*\|\s*"([^"]+)"[^`]*\}`/);
  if (!line) return ["closed", "taken"];
  return [line[1], line[2]];
}

function extractApiNames(md: string, sectionHeaderRegex: RegExp, nextSectionRegex: RegExp): string[] {
  const block = extractBetween(md, sectionHeaderRegex, nextSectionRegex);
  const out: string[] = [];
  const re = /^-\s+`([a-z0-9_.]+)\(args:/gim;
  for (const m of block.matchAll(re)) out.push(m[1]);
  return out;
}

export function extractAll(md: string): ExtractResult {
  const reservationStatuses = extractReservationStatuses(md);
  const errorCodes = extractErrorCodes(md);
  const services = extractServices(md);
  const languages = extractLanguages(md);
  const slotTakenReasons = extractSlotTakenReasons(md);

  const expectedQueries = extractApiNames(md, /^\s*###\s*6\.2\s*Queries\s*\n/m, /^\s*###\s*6\.3\s*/m);
  const expectedMutations = extractApiNames(md, /^\s*###\s*6\.3\s*Mutations\s*\(DB only\)\s*\n/m, /^\s*###\s*6\.4\s*/m);
  const expectedActions = extractApiNames(md, /^\s*###\s*6\.4\s*Actions\s*\(réseau externe\)\s*\n/m, /^\s*##\s*7\s*/m);

  return {
    reservationStatuses: uniq(reservationStatuses),
    errorCodes: uniq(errorCodes),
    services: uniq(services),
    languages: uniq(languages),
    slotTakenReasons: uniq(slotTakenReasons),
    expectedQueries: uniq(expectedQueries),
    expectedMutations: uniq(expectedMutations),
    expectedActions: uniq(expectedActions),
  };
}

export function buildGeneratedTs(result: ExtractResult, sourceRelativePath: string): string {
  const header = `/* eslint-disable */\n/*\n  THIS FILE IS AUTOGENERATED. DO NOT EDIT BY HAND.\n  Source of truth: ${sourceRelativePath}\n*/\n\n`;

  const constArray = (name: string, values: string[]) => {
    const lit = values.map((v) => JSON.stringify(v)).join(", ");
    return `export const ${name} = [${lit}] as const;\nexport type ${name} = (typeof ${name})[number];\n`;
  };

  const apiArrays = `export const ExpectedQueries = ${JSON.stringify(result.expectedQueries, null, 2)} as const;\nexport type ExpectedQueryName = (typeof ExpectedQueries)[number];\n\nexport const ExpectedMutations = ${JSON.stringify(result.expectedMutations, null, 2)} as const;\nexport type ExpectedMutationName = (typeof ExpectedMutations)[number];\n\nexport const ExpectedActions = ${JSON.stringify(result.expectedActions, null, 2)} as const;\nexport type ExpectedActionName = (typeof ExpectedActions)[number];\n`;

  const helpers = `\nexport function makeSlotKey(args: { dateKey: string; service: Service; timeKey: string }): string {\n  return \`\${args.dateKey}#\${args.service}#\${args.timeKey}\`;\n}\n\nexport function parseSlotKey(slotKey: string): { dateKey: string; service: Service; timeKey: string } {\n  const [dateKey, service, timeKey, ...rest] = slotKey.split("#");\n  if (!dateKey || !service || !timeKey || rest.length > 0) {\n    throw new Error("Invalid slotKey");\n  }\n  if (!(Service as readonly string[]).includes(service)) {\n    throw new Error("Invalid service in slotKey");\n  }\n  return { dateKey, service: service as Service, timeKey };\n}\n\nexport function computePartySize(adults: number, childrenCount: number, babyCount: number): number {\n  return adults + childrenCount + babyCount;\n}\n\nexport function computeEffectiveOpen(isOpen: boolean, capacity: number): boolean {\n  return isOpen === true && capacity > 0;\n}\n`;

  const zod = `\nimport { z } from "zod";\n\nexport const ErrorCodeSchema = z.enum(ErrorCode);\nexport const ErrorShapeSchema = z.object({\n  code: ErrorCodeSchema,\n  messageKey: z.string(),\n  meta: z.record(z.string(), z.unknown()).optional(),\n});\n\nexport const RateLimitedMetaSchema = z.object({ retryAfterMs: z.number() });\nexport const SlotTakenMetaSchema = z.object({\n  slotKey: z.string(),\n  reason: z.enum(SlotTakenReason).optional(),\n});\nexport const InsufficientCapacityMetaSchema = z.object({\n  slotKey: z.string(),\n  requestedPartySize: z.number(),\n  remainingCapacity: z.number(),\n});\nexport const VersionConflictMetaSchema = z.object({ expectedVersion: z.number(), actualVersion: z.number() });\nexport const TableConflictMetaSchema = z.object({ slotKey: z.string(), tableIds: z.array(z.string()) });\n\nexport const SettingsPublicSchema = z.object({\n  restaurantId: z.string(),\n  publicWidgetEnabled: z.boolean(),\n  turnstileSiteKey: z.string(),\n  maxPartySizeWidget: z.number(),\n  timezone: z.string(),\n}).strict();\n\nexport const SettingsAdminSchema = SettingsPublicSchema.extend({\n  resendFromEmail: z.string(),\n  resendFromName: z.string(),\n  manageTokenExpireBeforeSlotMs: z.number(),\n  rateLimit: z.object({ windowMs: z.number(), maxRequests: z.number() }),\n}).strict();\n\nexport const SlotSchema = z.object({\n  slotKey: z.string(),\n  dateKey: z.string(),\n  service: z.enum(Service),\n  timeKey: z.string(),\n  isOpen: z.boolean(),\n  capacity: z.number(),\n  remainingCapacity: z.number(),\n  maxGroupSize: z.number().nullable(),\n}).strict();\n`;

  return (
    header +
    constArray("ReservationStatus", result.reservationStatuses) +
    "\n" +
    constArray("ErrorCode", result.errorCodes) +
    "\n" +
    constArray("Service", result.services) +
    "\n" +
    constArray("Language", result.languages) +
    "\n" +
    constArray("SlotTakenReason", result.slotTakenReasons) +
    "\n" +
    apiArrays +
    helpers +
    zod
  );
}

export function generateFromMarkdownFile(args: { repoRoot: string; markdownRelativePath: string }): { outputPath: string; contents: string } {
  const mdPath = path.resolve(args.repoRoot, args.markdownRelativePath);
  const outPath = path.resolve(args.repoRoot, "spec/contracts.generated.ts");

  const mdRaw = fs.readFileSync(mdPath, "utf8");
  const md = normalizeEol(mdRaw);

  const extracted = extractAll(md);
  const generated = buildGeneratedTs(extracted, args.markdownRelativePath);
  return { outputPath: outPath, contents: generated };
}

function main(): void {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  const repoRoot = path.resolve(__dirname, "../..");

  const { outputPath, contents } = generateFromMarkdownFile({
    repoRoot,
    markdownRelativePath: "spec/CONTRACTS.md",
  });

  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, contents, "utf8");
}

if (import.meta.url === pathToFileURL(process.argv[1] ?? "").href) {
  main();
}
